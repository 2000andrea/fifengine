/***************************************************************************
 *   Copyright (C) 2005-2006 by the FIFE Team                              *
 *   fife-public@lists.sourceforge.net                                     *
 *   This file is part of FIFE.                                            *
 *                                                                         *
 *   FIFE is free software; you can redistribute it and/or modify          *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 *   This program is distributed in the hope that it will be useful,       *
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
 *   GNU General Public License for more details.                          *
 *                                                                         *
 *   You should have received a copy of the GNU General Public License     *
 *   along with this program; if not, write to the                         *
 *   Free Software Foundation, Inc.,                                       *
 *   51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA              *
 ***************************************************************************/

#ifndef RENDERABLE_PROVIDER_H
#define RENDERABLE_PROVIDER_H
#include <string>
#include "renderable.h"
#include "renderable_location.h"
#include <boost/intrusive_ptr.hpp>

namespace FIFE {
	class RenderableProvider;


	typedef ::boost::intrusive_ptr<RenderableProvider> RenderableProviderPtr;

	/** Abstract base class for RenderAble loaders.
	* Normally you won't have to bother with this class, as it is
	* generated by the ImageCache singleton.
	* @note Never delete this class or hold a naked pointer. Use the
	* RenderableProviderPtr instead, since it's reference counted.
	* You may however create new RenderableProviderPtr instances, as
	* the reference counting is intrusive.
	* @note When writing a RenderableProvider class (derived), please make
	* sure, that the constructor and destructors never throw exceptions.
	* Return NULL from the createRenderable() function instead.
	*/
	class RenderableProvider {
		public:
			RenderableProvider(const RenderableLocation& location);
			virtual ~RenderableProvider();

			/** Creates a RenderAble from a location
			* @return Zero on failure, the RenderAble otherwise.
			*/
			virtual RenderAble* createRenderable() = 0;

			/** This is called when the created renderable is removed from the
			 * cache. This basically is just a hint.
			 * I'm really not sure if this is worth anything.
			 */
			virtual void unload();

			/** Is this needed?
			 */
			const RenderableLocation& getLocation() const { return m_location; };
		protected:
			RenderableLocation m_location;
		private:
			long m_refcount;
			friend void intrusive_ptr_add_ref(RenderableProvider* p);
			friend void intrusive_ptr_release(RenderableProvider* p);
	};

	inline void intrusive_ptr_add_ref(RenderableProvider* p) {
		p->m_refcount++;
	};
	inline void intrusive_ptr_release(RenderableProvider* p) {
		p->m_refcount--;
		if( !p->m_refcount )
			delete p;
	};


} //FIFE


#endif
