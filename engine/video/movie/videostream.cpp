#include <cassert>
#include "util/exception.h"
#include "util/log.h"
#include "videostream.h"

namespace FIFE {
  VideoStream::VideoStream() {
    setNull();
  }

  void VideoStream::setNull() {
    formatCtx   = 0;
    codecCtx    = 0;
    codec       = 0;
    frame       = 0;
    frameRGB    = 0;
    vStreamId   = -1;
    vBuffer     = 0;
  }

  VideoStream::~VideoStream() {
    cleanup();
  }

  void VideoStream::cleanup() {
    if (frame)
      av_free(frame);
    if (frameRGB)
      av_free(frameRGB);
    if (codecCtx)
      avcodec_close(codecCtx);
    if (formatCtx)
      av_close_input_file(formatCtx);
    if (vBuffer)
      delete [] vBuffer;

    setNull();
  }

  void VideoStream::load(const std::string & file) {
    // assumes that: av_register_all has been called!

    if (frame || codecCtx || formatCtx)
      cleanup();

    if (av_open_input_file(&formatCtx, file.c_str(), 0, 0, 0) != 0)
      throw CannotOpenFile(file);

    if (av_find_stream_info(formatCtx) < 0)
      throw InvalidFormat(file);

    dump_format(formatCtx, 0, file.c_str(), 0);

    for (unsigned int i = 0; i < formatCtx->nb_streams; i++) {
      if (formatCtx->streams[i]->codec->codec_type == CODEC_TYPE_VIDEO) {
        vStreamId = i;
        break;
      }
    }
    if (vStreamId == -1)
      throw InvalidFormat(file);
    
    codecCtx = formatCtx->streams[vStreamId]->codec;
    assert(codecCtx);

    codec = avcodec_find_decoder(codecCtx->codec_id);

    // Inform the codec that we can handle truncated bitstreams -- i.e.,
    // bitstreams where frame boundaries can fall in the middle of packets
    if(codec->capabilities & CODEC_CAP_TRUNCATED)
        codecCtx->flags |= CODEC_FLAG_TRUNCATED;

    if(avcodec_open(codecCtx, codec) < 0)
      throw NotSupported(file);

/*
    // Hack to correct wrong frame rates that seem to be generated by some 
    // codecs
    if(codecCtx->frame_rate > 1000 && codecCtx->frame_rate_base == 1)
        codecCtx->frame_rate_base = 1000;
*/

    frame = avcodec_alloc_frame(); 
    assert(frame);
    frameRGB = avcodec_alloc_frame();
    assert(frameRGB);

    int n_bytes = avpicture_get_size(PIX_FMT_RGB24, codecCtx->width,
      codecCtx->height);
    vBuffer = new uint8_t[n_bytes];
    assert(vBuffer);

    avpicture_fill(reinterpret_cast<AVPicture*>(frameRGB), vBuffer, PIX_FMT_RGB24,
      codecCtx->width, codecCtx->height); 
  }

  float VideoStream::getFps() {
    //FIXME: should be an exception!
    assert(vStreamId != -1);
    return 1/av_q2d(codecCtx->time_base);
  }

  uint32_t VideoStream::getWidth() {
    //FIXME: should be an exception!
    assert(vStreamId != -1);
    return codecCtx->width;
  }

  uint32_t VideoStream::getHeight() {
    //FIXME: should be an exception!
    assert(vStreamId != -1);
    return codecCtx->height;
  }

  bool VideoStream::nextFrame() {
  //FIXME: should be an exception!
    assert(vStreamId != -1);

    bool      firstFrame = true;
    AVPacket  packet;
    uint8_t  *rawData = 0;
    int       remaining = 0;
    int       decoded   = 0;
    int       frameDone = 0;

    if (firstFrame) {
      firstFrame = false;
      packet.data = 0;
    }

    while (true) {
      while (remaining > 0) {
        decoded = avcodec_decode_video(codecCtx, frame, &frameDone,
          rawData, remaining);

        if (decoded < 0) {
          Warn(__FILE__) << "Error decoding frame";
          return false;
        }

        remaining -= decoded;
        rawData += decoded;

        if (frameDone)
          return true;
      }
      do {
        if (packet.data != NULL)
          av_free_packet(&packet);
        if (av_read_packet(formatCtx, &packet) < 0)
          goto loop_exit;
      } while (packet.stream_index != vStreamId);

      remaining = packet.size;
      rawData = packet.data;
    }

loop_exit:
    decoded = avcodec_decode_video(codecCtx, frame, &frameDone, 
        rawData, remaining);
    if (packet.data != NULL)
        av_free_packet(&packet);
    return (frameDone != 0);
  }
}
