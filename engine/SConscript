import os, sys
from utils.util_scripts.path import path as upath
Import('env')

joinpath = os.path.join
_sep = os.path.sep
enginepath = upath('.')

def is_implfile(fname):
	return fname.endswith('.cpp') or fname.endswith('.cxx')

def is_headerfile(fname):
	return fname.endswith('.hpp') or fname.endswith('.h')

def generate_swig_wrappers(interfacefiles):
	swigoutdir = joinpath('generatedfiles', 'swigwrappers')

	def generate_language_specifics(lang):
		print "   Generating language specific wrappers for " + lang
		langoutdir = joinpath(swigoutdir, lang)
		os.system('swig -c++ -%s fife.i' % (lang))
		wrappers = enginepath.files('*_wrap*')
		for wrapper in wrappers:
			wrapper.move(langoutdir)

	print "Running swig..."
	inclusions = ['%module fife'] + ['%include ' + str(f) for f in interfacefiles]
	open('fife.i', 'w').write('\n'.join(inclusions))
	generate_language_specifics(env['script'])
	os.remove('fife.i')
	print "Swig completed"

def remove_based_on_dir_filter(dirfilters, files):
	abspaths = []
	for pathstr in dirfilters:
		abspaths.append(os.path.abspath(joinpath(*pathstr.split('/'))))

	result = []
	for f in files:
		filtered = False
		for p in abspaths:
			if str(f.abspath()).find(p) != -1:
				filtered = True
				break
		if not filtered:
			result.append(f)
	return result

def check_for_duplicate_files(files):
	dupePaths = {}; dupes = []
	for f in files:
		fname = os.path.basename(f)
		try:
			dupePaths[fname].append(f)
		except KeyError:
			dupePaths[fname] = [f]
	for fname, paths in dupePaths.items():
		if len(paths) > 1:
			dupes.append('%s -> %s' % (fname, ', '.join(paths)))
	if dupes:
		print "\nError found: All cpp file names must be unique in FIFE, the following were not:"
		for l in dupes: print l
		Exit(1)

def clean_generated_files():
	print "Cleaning generated files ..."
	for genfile in upath('generatedfiles').walkfiles():
		genfile.remove()


def generate_msvc_project(projectfiles):
	def create_dict_tree(source_dict):
		for f in source_dict.keys():
			parts = f.split(os.path.sep, 1)
			if len(parts) > 1:
				try:
					source_dict[parts[0]][parts[1]] = {}
				except KeyError:
					source_dict[parts[0]] = {}
					source_dict[parts[0]][parts[1]] = {}
				del source_dict[f]
		for k, d in source_dict.items():
			create_dict_tree(d)
		return source_dict
	
	def get_msvc_repr(d, tabcount=2, curpath=''):
		retstr = []
		for k in sorted(d.keys()):
			newpath = os.path.join(curpath, k)
			if len(d[k].keys()):
				retstr.append(tabcount * '\t' + '<Filter Name="%s">' % k)
				retstr.append(get_msvc_repr(d[k], tabcount+1, newpath))
				retstr.append(tabcount * '\t' + '</Filter>')
			else:
				newpath = os.path.join('..', '..', '..', 'engine', newpath)
				retstr.append(tabcount * '\t' + '<File RelativePath="%s"></File>' % newpath.replace('/','\\'))
		return '\n'.join(retstr)
			
	msvcbuildpath = joinpath('..', 'build', 'win32', 'msvc2005')
	vcpaths = [os.path.abspath(f).split('%sengine%s' % (_sep, _sep))[-1] for f in projectfiles]
	xmlstr = get_msvc_repr(create_dict_tree(dict([[p, {}] for p in vcpaths])))
	projtxt = open(joinpath(msvcbuildpath, 'fifeproj_template.xml'), 'r').read()
	projtxt = projtxt.replace('__FILE_INSERTION_POINT__', xmlstr)
	vcprojfilename = joinpath(msvcbuildpath, 'fife.vcproj')
	open(vcprojfilename, 'w').write(projtxt)
	print "FIFE msvc project file succesfully created (%s)" % os.path.abspath(vcprojfilename)


def generate_codeblocks_project(projectfiles):
	codeblocksHeaderDef = \
	'''		<Unit filename="..\..\..\engine\%s">
				<Option compilerVar=""/>
				<Option compile="0"/>
				<Option link="0"/>
				<Option target="default"/>
			</Unit>'''
	
	codeblocksCppDef = \
	'''		<Unit filename="..\..\..\engine\%s">
				<Option compilerVar="CPP"/>
				<Option target="default"/>
			</Unit>'''
	cbbuildpath = joinpath('..', 'build', 'win32', 'code_blocks')
	xmlstr = []
	for f in projectfiles:
		newf = os.path.abspath(f).split('%sengine%s' % (_sep, _sep))[-1]
		newf = newf.replace('/', '\\')
		if f in headerfiles:
			xmlstr.append(codeblocksHeaderDef % newf)
		else:
			xmlstr.append(codeblocksCppDef % newf)
	projtxt = open(joinpath(cbbuildpath, 'fifelib_template.xml'), 'r').read()
	projtxt = projtxt.replace('__FILE_INSERTION_POINT__', '\n'.join(xmlstr))
	cbprojfilename = joinpath(cbbuildpath, 'fife lib.cbp')
	open(cbprojfilename, 'w').write(projtxt)
	print "FIFE code::blocks project file succesfully created (%s)" % os.path.abspath(cbprojfilename)


clean_generated_files()
variated_dirs = eval(open(joinpath('config', 'variated_dirs'), 'r').read())
filteredpaths = []
for flag, paths in variated_dirs.items():
	value = None
	if flag.find('-') != -1:
		flag, value = flag.split('-')
	if (value and (not env[flag] == value)) or (not env[flag]):
		filteredpaths.extend(paths)

if not env.GetOption('clean'):
	interfacefiles = remove_based_on_dir_filter(filteredpaths, list(enginepath.walkfiles('*.i')))
	generate_swig_wrappers(interfacefiles)

allfiles = list(enginepath.walkfiles())
headerfiles = [f for f in allfiles if is_headerfile(f)]
implfiles = [f for f in allfiles if is_implfile(f)]

if not env.GetOption('clean'):
	filtered_prj_paths = eval(open(joinpath('config', 'removed_from_project_files'), 'r').read())
	filtered_prj_paths = [joinpath(*p.split('/')) for p in filtered_prj_paths]
	projectfiles = remove_based_on_dir_filter(filtered_prj_paths, headerfiles + implfiles)
	projectfiles.sort()
	
	generate_msvc_project(projectfiles)
	generate_codeblocks_project(projectfiles)

if not env['projfiles']:
	print "Starting compilation"
	env.Append(CPPPATH = ['#/engine'])
	compilefiles = [str(f) for f in remove_based_on_dir_filter(filteredpaths, implfiles)]
	flib = env.SharedLibrary('fife', compilefiles, LINKFLAGS=['-Wl,-rpath,../ext/install/lib,-rpath,ext/install/lib'])
	env.InstallAs(['generatedfiles/swigwrappers/%s/_fife.so' % env['script']], [flib])
